////////////////////////////////////////////////////////////////////////////////
//
// Package:   Geofrenzy Robot ROS Package
//
// Link:      https://github.com/roadnarrows-robotics/geofrenzy
//
// File:      gf_scene.h
//
/*! \file
 *
 * \brief The Geofrenzy scene interface.
 *
 * A scene is composed of one or more geofences along with attached attributes.
 *
 * From the scene features, a synthetic set of depth plus color points may be
 * generated. These data points can be converted to a standard set of
 * ROS messages to create virtual sensors such as structured light sensors and
 * laser scanners. The output are point clouds.
 *
 * \note Simple geometric objects are used. If there is a requriement for more 
 * realism and/or features, then more extensive graphics libraries will be
 * needed, such as openscenegraph, cgal, and opengl.
 *
 * \author Bill Coon (bill@roadnarrows.com)
 * \author Robin Knight (robin.knight@roadnarrows.com)
 *
 * \par Maintainer:
 * Chris Stradtman (chris.stradtman@geo.network)
 *
 * \par Copyright:
 * (C) 2017  GeoNetwork
 * (http://www.geo.network)
 * \n All Rights Reserved
 *
 * \par License
 * Apache 2.0
 * 
 * EULA:
 * See EULA.md
 */
////////////////////////////////////////////////////////////////////////////////

#ifndef _GF_SCENE_H
#define _GF_SCENE_H

#include <math.h>

#include <string>
#include <limits>
#include <ostream>

#include <Eigen/Eigen>
#include <Eigen/Geometry>

#include "geofrenzy/Polygon64.h"

#include "gf_math.h"
#include "gf_poly.h"

//
// Debug macro
//
#undef DBG_SCENE_ENABLE   ///< define or undef
#ifdef DBG_SCENE_ENABLE
#define DBG_SCENE(_obj)  \
  std::cerr << "DBG: " << __func__ << "() " << _obj << std::endl
#else
#define DBG_SCENE(_obj)
#endif // DBG_SCENE_ENABLE


namespace geofrenzy
{
  namespace gf_scene
  {
    /*!
     * \defgroup gfscene Geofrence Scene
     * 
     * Geofences make up a virtual scene. An geofence is built up of a 
     * surface and a set of attributes.
     * \{
     */

    //--------------------------------------------------------------------------
    // Scene Data Types, Constants, and Defines
    //--------------------------------------------------------------------------
 
    //
    // Type shorteners. (Mama's little baby loves short'nin' bread)
    //
    typedef gf_math::EigenRGBA        LuxRGBA;        ///< RGB+Alpha intensities
    typedef gf_math::EigenXYZRGBA     CloudPoint;     ///< cloud point
    typedef gf_math::EigenXYZRGBAList PointCloudList; ///< point cloud list

    /*!
     * \brief Minimum fence height (meters).
     */
    const double FenceMinHeight = 0.10;

    /*!
     * \brief Default fence color. 50% transparent blueish gray.
     */
    const LuxRGBA FenceColorDft(0.30, 0.30, 0.45, 0.50);

    /*!
     * \brief Scene Points of Interest structure.
     * 
     * PoI's are candidate points generated by scanners or other algorithms.
     */
    struct ScenePoI
    {
      gf_math::EigenPoint3 m_xyz;   ///< xyz point
      gf_math::EigenRGBA   m_rgba;  ///< rgba color
    };

    /*!
     * \brief Ordered map of ray points of interest.
     *
     * - Key:   Parametric line value t.
     * - Value: Ray point of interest information.
     *
     * \note  The std::map container container automatically keeps the map in
     *        a natural ascending order by key.
     */
    typedef std::map<double, ScenePoI> RayPoIMap;

    /*!
     * \brief Scanning bit-or'ed options.
     */
    enum ScanOptions
    {
      /*!
       * The default scanning option.
       *  - Include all instersecting points along any traced ray. This option
       *    excludes use of the 2D option.
       *  - Do not produce any 2D structure. That is, if no intersection along
       *    a traced ray is detected, no point is added.
       *  - Do not alpha blend colors along ray.
       */
      ScanOptionDft = 0x00,

      /*!
       * Generate a full height x width 2D structure of points. Any "no object"
       * point has a value of inf.
       */
      ScanOption2D  = 0x01,

      /*!
       * Include only the nearest point of a set of intersections along a
       * traced ray.
       */
      ScanOptionNearest = 0x02,

      /*!
       * Alpha blend colors.
       */
      ScanOptionAlphaBlend = 0x04
    };

    ///@{
    /*!
     * \brief Useful scan option macros.
     *
     * \param _opt  Option bits
     *
     * \return Boolean
     */
    #define SCANOPT_2D(_opt)            ((_opt) & ScanOption2D)
    #define SCANOPT_ALPHA_BLEND(_opt)   ((_opt) & ScanOptionAlphaBlend)
    #define SCANOPT_NEAREST_ONLY(_opt)  ((_opt) & ScanOptionNearest)
    #define SCANOPT_XRAY_VIS(_opt)      !SCANOPT_NEAREST_ONLY(_opt)
    ///@}


    //--------------------------------------------------------------------------
    // Class Geofence
    //--------------------------------------------------------------------------

    /*!
     * \brief A simple wrapper class around a geofence polyhedral surface.
     * 
     * If a geofence requires more metadata, this wrapper readily allows for
     * that data expansion.
     */
    class Geofence
    {
    public:
      /*!
       * \brief Default constructor.
       *
       * \param id    Geofence identifier.
       * \param text  Geofence descriptive text.
       */
      Geofence(const size_t id = 0, const std::string &text = "");

      /*!
       * \brief Copy constructor.
       *
       * \param src   Source object.
       */
      Geofence(const Geofence &src);

      /*!
       * \brief Destructor.
       */
      virtual ~Geofence();

      /*!
       * \brief Clear the fence.
       */
      void clear();

      /*!
       * \brief Return the geofence id.
       *
       * \return Id.
       */
      size_t id() const
      {
        return m_id;
      }
      
      /*!
       * \brief Return the geofence descriptive text.
       *
       * \return Text string reference.
       */
      const std::string &text() const
      {
        return m_text;
      }

      /*!
       * \brief Set the geofence descriptive text.
       *
       * \param text  Text string.
       */
      void text(const std::string &text)
      {
        m_text = text;
        m_polyhedron.text(text);
      }

      /*!
       * \brief Return if this geofence is capped.
       *
       * \return Returns true or false.
       */
      bool hasCaps() const
      {
        return m_hasCaps;
      }

      /*!
       * \brief Set whether this geofence is capped or not.
       *
       * \param tf  Gefence does [not] have caps.
       */
      void hasCaps(bool tf)
      {
        m_hasCaps = tf;
      }

      /*!
       * \brief Return the polyhedral surface defining the geofence.
       *
       * \return Reference to polyhedron.
       */
      gf_math::EigenPolyhedron &polyhedron()
      {
        return m_polyhedron;
      }

      /*!
       * \brief Return the polyhedral surface defining the geofence.
       *
       * \return Constant reference to polyhedron.
       */
      const gf_math::EigenPolyhedron &polyhedron() const
      {
        return m_polyhedron;
      }

      /*!
       * \brief Stream insertion operator.
       *
       * \param os  Output stream.
       * \param obj Object to insert.
       *
       * \return Reference to output stream.
       */
      friend std::ostream &operator<<(std::ostream &os, const Geofence &obj);

    protected:
      //
      // Metadata
      //
      size_t      m_id;       ///< geofence id
      bool        m_hasCaps;  ///< geofence object does [not] have caps
      std::string m_text;     ///< description of fence, name, and/or owner

      //
      // The fence
      //
      gf_math::EigenPolyhedron  m_polyhedron; ///< geofence boundary
    };

    //
    // Geofence objects list types.
    //
    typedef std::vector<Geofence>         GeofenceList;  ///< fence list
    typedef GeofenceList::iterator        GeofenceIter;  ///< fence iter
    typedef GeofenceList::const_iterator  GeofenceCIter; ///< fence citer


    //--------------------------------------------------------------------------
    // Class GeofenceScene
    //--------------------------------------------------------------------------

    /*!
     * \brief GeofenceScene descriptor container class.
     *
     * A geofence scene contains a set of geofences along with associated
     * attributes. A geofence is a a virtual geographic boundary.
     *
     * A geofence usually defines a closed space, but it may be open (think
     * the Great Wall of China).
     *
     * A geofence perimeter is composed of connected, vertically oriented,
     * rectangular polygons. This perimeter then forms a polyhedral surface.
     * Horizontal ceiling and floor caps may added to a closed geofence to
     * form a right prism polyhedron. A right prism is a prism in which the
     * joining edges and faces are perpendicular to the base faces.
     *
     * The base footprint of the geofence may outline either a convex or concave
     * polygon.
     */
    class GeofenceScene
    {
    public:
      /*!
       * \brief Default constructor.
       */
      GeofenceScene();

      /*!
       * \brief Destructor.
       */
      virtual ~GeofenceScene();

      /*!
       * \brief Add a geofence to the scene.
       *
       * \param id          Geofence identifier.
       * \param polygon     ROS polygon defining a fence. Each (x,y,z) point
       *                    specifies a distance from a reference point of an
       *                    observer (meters).
       * \param color       Color attribute applied to the fence.
       *                    (red-green-blue intensities + alpha).
       * \param fenceAlt    Base altitude from ground (meters).
       * \param fenceHeight Height of fence from base (meters).  
       * \param hasCaps     The object is a polyhedron. That is, it has both
       *                    top(ceiling) and bottom(floor) horizontal caps.
       * \param text        Optional informative text.
       */
      void addFence(const size_t      fenceId,
                    const Polygon64   &polygon,
                    const LuxRGBA     &color,
                    const double      fenceAlt,
                    const double      fenceHeight,
                    const bool        hasCaps,
                    const std::string &text = "");

      /*!
       * \brief Clear scene of all data.
       */
      void clear();

      /*!
       * \brief Return the size (number of geofences) in scene.
       *
       * \return Size.
       */
      size_t size() const
      {
        return m_geofences.size();
      }

      /*!
       * \brief Return the number of geofences in scene.
       *
       * Same as size().
       *
       * \return Number of fences.
       */
      size_t numOfFences() const
      {
        return m_geofences.size();
      }

      /*!
       * \brief Return the geofence at index i.
       *
       * \param i Fence index.
       *
       * \return Geofence object.
       */
      Geofence &fenceAt(size_t i)
      {
        assert(i < m_geofences.size());
        return m_geofences[i];
      }

      /*!
       * \brief Return the geofence at index i.
       *
       * \param i Fence index.
       *
       * \return Constant Geofence object.
       */
      const Geofence &fencetAt(size_t i) const
      {
        assert(i < m_geofences.size());
        return m_geofences[i];
      }

      /*!
       * \brief Return an iterator pointing to the first element of the list
       * of geofences.
       *
       * \return Iterator.
       */
      GeofenceIter iterFenceBegin()
      {
        return m_geofences.begin();
      }

      /*!
       * \brief Return an iterator referring to the past-the-end element of
       * the list of goefences.
       *
       * \return Iterator.
       */
      GeofenceIter iterFenceEnd()
      {
        return m_geofences.end();
      }

      /*!
       * \brief Return a constant iterator pointing to the first element of
       * the list of goefences.
       *
       * \return Constant Iterator.
       */
      GeofenceCIter iterFenceBegin() const
      {
        return m_geofences.begin();
      }

      /*!
       * \brief Return a constant iterator referring to the past-the-end
       * element of the list of goefences.
       *
       * \return Constant Iterator.
       */
      GeofenceCIter iterFenceEnd() const
      {
        return m_geofences.end();
      }

      /*!
       * \brief Stream insertion operator.
       *
       * \param os  Output stream.
       * \param obj Object to insert.
       *
       * \return Reference to output stream.
       */
      friend std::ostream &operator<<(std::ostream        &os,
                                      const GeofenceScene &obj);

    protected:
      GeofenceList  m_geofences;    ///< list of geofences

    }; // class GeofenceScene


    //--------------------------------------------------------------------------
    // Class SceneScanner
    //--------------------------------------------------------------------------

    /*!
     * \brief Scene scanner virtual base class.
     */
    class SceneScanner
    {
    public:
      /*!
       * \brief Default constructor.
       *
       * \param strScannerName  Name of scanner.
       */
      SceneScanner(const std::string &strScannerName) :
          m_name(strScannerName)
      {
      }

      /*!
       * \brief Destructor.
       */
      virtual ~SceneScanner()
      {
      }

      /*!
       * \brief Scan virtual member function.
       *
       * \param       scene       Scene to scan.
       * \param[out]  intersects  Output list of xyz rgba points.
       *
       * \return Number of points.
       */
      virtual size_t scan(const GeofenceScene &scene,
                          PointCloudList      &intersects) = 0;

      /*!
       * \brief Return name of this scanner.
       *
       * \return Constant reference to string name.
       */
      const std::string &name() const
      {
        return m_name;
      }

      /*!
       * \brief Stream insertion operator.
       *
       * \param os  Output stream.
       * \param obj Object to insert.
       *
       * \return Reference to output stream.
       */
      friend std::ostream &operator<<(std::ostream       &os,
                                      const SceneScanner &obj);

    protected:
      std::string m_name;   ///< scanner name

      ///@{
      /*!
       * \brief Push xyz point with the associated rgba color onto intersect
       * list.
       *
       * \param[out]  intersects  List of intersecting points.
       * \param       xyz         Depth (x,y,z) point.
       * \param       rgba        Color intensity red-green-blue-alpha point.
       * \param       poi         Scene point of interest.
       */
      void pushIntersect(PointCloudList             &intersects,
                         const gf_math::EigenPoint3 &xyz,
                         const LuxRGBA              &rgba)
      {
        CloudPoint  pt;

        pt << xyz, rgba;
        intersects.push_back(pt);
      }

      void pushIntersect(PointCloudList &intersects,
                         const ScenePoI &poi)
      {
        CloudPoint  pt;

        pt << poi.m_xyz, poi.m_rgba;
        intersects.push_back(pt);
      }
      ///@}

    }; // class SceneScanner


    //--------------------------------------------------------------------------
    // Class GridSceneScanner
    //--------------------------------------------------------------------------

    /*!
     * \brief Geofence scene grid scanner class.
     */
    class GridSceneScanner : public SceneScanner
    {
    public:
      static const double GridSizeMin;    ///< grid size minimum (meters)
      static const double GridSizeDft;    ///< grid size default (meters)

      /*!
       * \brief Default constructor.
       */
      GridSceneScanner();

      /*!
       * \brief Initialization constructor.
       * 
       * \param       gridSize    Grid size (meters).
       * \param       options     Options to control the scan.
       */
      GridSceneScanner(const double   gridSize,
                       const uint32_t options = ScanOptionDft);

      /*!
       * \brief Destructor.
       */
      virtual ~GridSceneScanner();

      /*!
       * \brief (Re)Set scanner properties.
       *
       * \param gridSize    Grid size (meters).
       */
      void setProperties(const double gridSize);

      /*!
       * \brief Scan virtual scene to generate a list of intersecting depth plus
       * color points.
       *
       * With this scanner, the scene is a priori knowledge. A fast grid of the
       * fences is performed. Kant get better than this.
       *
       * \param       scene       Scene to scan.
       * \param[out]  intersects  Output list of xyzrgba points where xyz values
       *                          are in meters, rgb in intensities [0.0, 1.0],
       *                          and alpha [0.0, 1.0] transparent to opaque.
       *
       * \return Number of points.
       */
      virtual size_t scan(const GeofenceScene &scene,
                          PointCloudList      &intersects);

      /*!
       * \brief Stream insertion operator.
       *
       * \param os  Output stream.
       * \param obj Object to insert.
       *
       * \return Reference to output stream.
       */
      friend std::ostream &operator<<(std::ostream           &os,
                                      const GridSceneScanner &obj);

    protected:
      double    m_gridSize;   ///< grid size (m)
      uint32_t  m_options;    ///< options to control the scan.

      /*!
       * \brief Grid a vertical wall.
       *
       * \param       facet       Geofence vertical polyhedral facet.
       * \param[out]  intersects  Appended list of xyzrgba points.
       *
       * \return Number of points.
       */
      size_t gridWall(const gf_math::EigenFacet &facet,
                      PointCloudList            &intersects);

      /*!
       * \brief Grid a vertical stripe on a vertical wall.
       *
       * \param       facet       Geofence vertical polyhedral facet.
       * \param       basept      Starting facet base point.
       * \param[out]  intersects  Appended list of xyzrgba points.
       *
       * \return Number of points.
       */
      size_t gridWallStripe(const gf_math::EigenFacet  &facet,
                            const gf_math::EigenPoint3 &basept,
                            PointCloudList             &intersects);

      /*!
       * \brief Grid a horizontal cap.
       *
       * \param       facet       Geofence horizontal polyhedral facet.
       * \param[out]  intersects  Appended list of xyzrgba points.
       *
       * \return Number of points.
       */
      size_t gridCap(const gf_math::EigenFacet &facet,
                     PointCloudList            &intersects);

    }; // class GridSceneScanner


    //--------------------------------------------------------------------------
    // Class SensorSceneScanner
    //--------------------------------------------------------------------------

    /*!
     * \brief Geofence scene sensor scanner class.
     */
    class SensorSceneScanner : public SceneScanner
    {
    public:
      //
      // Width resolution
      //
      static const size_t WidthMin;   ///< minimum scan width (steps)
      static const size_t WidthDft;   ///< default scan width (steps)

      //
      // Height resolution
      //
      static const size_t HeightMin;  ///< minimum scan height (steps)
      static const size_t HeightDft;  ///< default scan height (steps)

      //
      // Horizontal Field of View
      //
      static const double HFoVMinMin; ///< horizontal minimum minimum (radians)
      static const double HFoVMaxMax; ///< horizontal maximum maximum (radians)
      static const double HFoVMinDft; ///< horizontal default minimum (radians)
      static const double HFoVMaxDft; ///< horizontal default maximum (radians)

      //
      // Vertical Field of View
      //
      static const double VFoVMinMin; ///< vertical minimum minimum (radians)
      static const double VFoVMaxMax; ///< vertical maximum maximum (radians)
      static const double VFoVMinDft; ///< vertical default minimum (radians)
      static const double VFoVMaxDft; ///< vertical default maximum (radians)

      /*!
       * \brief Default constructor.
       */
      SensorSceneScanner();

      /*!
       * \brief Initialization constructor.
       *
       * \param thetaMin  Azimuthal minimum angle from x+ axis (-pi, pi].
       * \param thetaMax  Azimuthal maximum angle from x+ axis (-pi, pi].
       * \param phiMin    Polar minimum angle from z+ [0, pi].
       * \param phiMax    Polar maximum angle from z+ [0, pi].
       * \param width     Width resolution. Number of horizontal points.
       * \param height    Height resoluion. Number of vertical points.
       */
      SensorSceneScanner(const double thetaMin, const double thetaMax,
                         const double phiMin,   const double phiMax,
                         const size_t width,    const size_t height,
                         const uint32_t         options = ScanOptionDft);

      /*!
       * \brief Destructor.
       */
      virtual ~SensorSceneScanner();

      /*!
       * \brief (Re)Set scanner properties.
       *
       * \param thetaMin  Azimuthal minimum angle from x+ axis (-pi, pi].
       * \param thetaMax  Azimuthal max angle from x+ axis (-pi, pi].
       * \param phiMin    Polar minimum angle from z+ [0, pi].
       * \param phiMax    Polar maximum angle from z+ [0, pi].
       * \param width     Width resolution. Number of horizontal points.
       * \param height    Height resoluion. Number of vertical points.
       */
      void setProperties(const double thetaMin, const double thetaMax,
                         const double phiMin,   const double phiMax,
                         const size_t width,    const size_t height);

      /*!
       * \brief Scan virtual scene to generate a list of intersecting depth plus
       * color points.
       *
       * With this scanner, the scene is a posteriori knowledge that is detected       * by a virtual scanning sensor.
       *
       * Scanning proceeds from the minimum to maximum phi in height steps, with
       * each step sweeping from the minimum to maximum theta in width steps.
       *
       * The spherical angles are as used in mathematics.
       *
       * \param       scene       Scene to scan.
       * \param[out]  intersects  Output list of xyzrgba points where xyz values
       *                          are in meters, rgb in intensities [0.0, 1.0],
       *                          and alpha [0.0, 1.0] transparent to opaque.
       *                          Order of the points is determined by the
       *                          options.
       *
       * \return Number of points.
       */
      virtual size_t scan(const GeofenceScene &scene,
                          PointCloudList      &intersects);

      /*!
       * \brief Stream insertion operator.
       *
       * \param os  Output stream.
       * \param obj Object to insert.
       *
       * \return Reference to output stream.
       */
      friend std::ostream &operator<<(std::ostream             &os,
                                      const SensorSceneScanner &obj);

    protected:
      double    m_thetaMin;   ///< azimuthal min angle from x+ axis (-pi, pi]
      double    m_thetaMax;   ///< azimuthal max angle from x+ axis (-pi, pi]
      double    m_phiMin;     ///< polar minimum angle from z+ [0, pi]
      double    m_phiMax;     ///< polar maximum angle from z+ [0, pi]
      size_t    m_width;      ///< width resolution
      size_t    m_height;     ///< height resoluion
      double    m_thetaStep;  ///< theta step size (radians)
      double    m_phiStep;    ///< phi step size (radians)
      uint32_t  m_options;    ///< options to control the scan.

      /*!
       * \brief Trace a ray through the scene to find geofence intersects.
       *
       * \param       theta       Ray azimuthal angle from x+ axis (-pi, pi].
       * \param       phi         Ray polar angle from z+ [0, pi].
       * \param       scene       Scene to project ray.
       * \param[out]  intersects  Appended list of xyzrgba points.
       *
       * \return Number of points.
       */
      virtual size_t traceRay(const double        theta,
                              const double        phi,
                              const GeofenceScene &scene,
                              PointCloudList      &intersects);

      /*!
       * \brief Post-process ray points of interest.
       *
       * The scanning options determine the accepted intersects.
       * See \ref ScanOptions for details.
       *
       * \param[in]   rayPoI      Points of interest.
       * \param[out]  intersects  Appended list of xyzrgba points.
       *
       * \return Number of points.
       */
      virtual size_t postproc(RayPoIMap &rayPoI, PointCloudList &intersects);

    }; // class SensorSceneScanner

    /*! \} */ // gfmath_scene


    //--------------------------------------------------------------------------
    // Unit Tests
    //--------------------------------------------------------------------------

#undef GF_SCENE_UT  ///< define/undef to enable/disable unit test functions.

#ifdef GF_SCENE_UT
    /*!
     * \defgroup gfscene_ut Unit Test
     * \{
     */

    const int UtPolynumTriangle   = 0;  ///< equalateral triangle with 50m sides
    const int UtPolynumRectangle  = 1;  ///< 20m x 30m rectangle
    const int UtPolynumHexagon    = 2;  ///< hexagon with 10m sides
    const int UtPolynumTee        = 3;  ///< 40m x 50m tee 

    /*!
     * \brief Make a ROS polygon message from a canned shape.
     *
     * \param polynum       Canned shape number. See above.
     * \param offset        Offset added to polygon position.
     * \param scale         Polygon size scale multiplier. 
     * \param [out] polygon Output ROS polygon message.
     */
    void utMakeCannedPolygon(const int         polynum,
                             const gf_math::EigenPoint3 &offset,
                             const double      scale,
                             Polygon64         &polygon);

#endif // GF_SCENE_UT

    /*! \} */ // end of gfscene_ut group
    
  } // namespace gf_scene

} // namespace geofrenzy

#endif // _GF_SCENE_H
